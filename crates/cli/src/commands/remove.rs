//! Remove components from a project.
//!
//! Deletes component source files and updates mod.rs.

use std::path::PathBuf;

use anyhow::{Context, Result, bail};
use clap::Args;
use dialoguer::Confirm;
use shadcn_ui_registry::default_registry;

use crate::config::Config;

#[derive(Args)]
pub struct RemoveArgs {
    /// Component names to remove
    pub components: Vec<String>,
}

pub async fn run(args: RemoveArgs) -> Result<()> {
    if args.components.is_empty() {
        bail!(
            "Please specify component names to remove.\n\nUsage: shadcn-ui remove <component...>"
        );
    }

    let config = Config::load(&PathBuf::from("."))
        .context("No shadcn-ui.toml found. Run `shadcn-ui init` first.")?;

    let registry = default_registry();
    let components_path = PathBuf::from(&config.project.components_dir);

    if !components_path.exists() {
        bail!(
            "Components directory does not exist: {}",
            config.project.components_dir
        );
    }

    // Warn about components that depend on the ones being removed
    let mut dependents: Vec<(String, String)> = Vec::new();
    for component in &registry.components {
        for dep in &component.dependencies {
            if args.components.contains(dep) {
                let dep_file = components_path.join(format!("{}.rs", component.name));
                if dep_file.exists() {
                    dependents.push((component.name.clone(), dep.clone()));
                }
            }
        }
    }

    if !dependents.is_empty() {
        println!("Warning: the following installed components depend on components being removed:");
        for (dependent, dep) in &dependents {
            println!("  {} depends on {}", dependent, dep);
        }
        println!();

        let proceed = Confirm::new()
            .with_prompt("Continue anyway?")
            .default(false)
            .interact()
            .context("Failed to read prompt input")?;

        if !proceed {
            println!("Aborted.");
            return Ok(());
        }
    }

    let mut removed_count = 0;

    for name in &args.components {
        let file_path = components_path.join(format!("{}.rs", name));
        if file_path.exists() {
            std::fs::remove_file(&file_path)
                .with_context(|| format!("Failed to remove {}", file_path.display()))?;
            println!("  - Removed {}.rs", name);
            removed_count += 1;
        } else {
            println!("  - {}.rs not found, skipping", name);
        }
    }

    // Update mod.rs to remove the modules
    update_mod_rs_remove(&components_path, &args.components)?;

    println!();
    println!("Removed {} component(s).", removed_count);

    Ok(())
}

/// Update mod.rs to remove the specified modules.
fn update_mod_rs_remove(components_dir: &std::path::Path, removed: &[String]) -> Result<()> {
    let mod_path = components_dir.join("mod.rs");
    if !mod_path.exists() {
        return Ok(());
    }

    let content = std::fs::read_to_string(&mod_path)?;
    let mut modules: Vec<String> = content
        .lines()
        .filter_map(|line| {
            let trimmed = line.trim();
            if trimmed.starts_with("pub mod ") && trimmed.ends_with(';') {
                Some(
                    trimmed
                        .strip_prefix("pub mod ")
                        .unwrap()
                        .strip_suffix(';')
                        .unwrap()
                        .to_string(),
                )
            } else {
                None
            }
        })
        .collect();

    modules.retain(|m| !removed.contains(m));
    modules.sort();

    let new_content = if modules.is_empty() {
        "//! UI components generated by shadcn-ui.\n".to_string()
    } else {
        format!(
            "//! UI components generated by shadcn-ui.\n\n{}\n",
            modules
                .iter()
                .map(|m| format!("pub mod {};", m))
                .collect::<Vec<_>>()
                .join("\n")
        )
    };

    std::fs::write(&mod_path, new_content)
        .with_context(|| format!("Failed to write {}", mod_path.display()))?;

    Ok(())
}
